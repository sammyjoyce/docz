const std = @import("std");
const caps_mod = @import("../caps.zig");
const precise_palette = @import("precise_ansi_palette.zig");

/// Terminal color management system with comprehensive color support
/// Provides unified interface for color operations across different terminal capabilities
pub const TerminalColorManager = struct {
    allocator: std.mem.Allocator,
    caps: caps_mod.TermCaps,
    color_cache: std.AutoHashMap(u32, []u8),
    palette_cache: std.AutoHashMap(u8, precise_palette.RGBColor),

    /// Color capability levels
    pub const ColorCapability = enum {
        basic_16, // Standard 16 ANSI colors
        extended_256, // ANSI 256-color palette
        truecolor_24bit, // 24-bit RGB colors
        adaptive, // Automatically detect and use best available
    };

    /// Color scheme types
    pub const ColorScheme = enum {
        dark,
        light,
        high_contrast,
        colorblind_friendly,
        custom,
    };

    /// Initialize color manager with terminal capabilities
    pub fn init(allocator: std.mem.Allocator, caps: caps_mod.TermCaps) !*TerminalColorManager {
        const self = try allocator.create(TerminalColorManager);
        self.* = TerminalColorManager{
            .allocator = allocator,
            .caps = caps,
            .color_cache = std.AutoHashMap(u32, []u8).init(allocator),
            .palette_cache = std.AutoHashMap(u8, precise_palette.RGBColor).init(allocator),
        };

        // Initialize palette cache
        try self.initPaletteCache();

        return self;
    }

    /// Deinitialize color manager
    pub fn deinit(self: *TerminalColorManager) void {
        var color_iter = self.color_cache.valueIterator();
        while (color_iter.next()) |sequence| {
            self.allocator.free(sequence.*);
        }
        self.color_cache.deinit();
        self.palette_cache.deinit();
        self.allocator.destroy(self);
    }

    /// Initialize the palette cache with ANSI 256 colors
    fn initPaletteCache(self: *TerminalColorManager) !void {
        for (precise_palette.ANSI_256_PALETTE, 0..) |color, i| {
            try self.palette_cache.put(@intCast(i), color);
        }
    }

    /// Get the best color capability for current terminal
    pub fn getColorCapability(self: *TerminalColorManager) ColorCapability {
        if (self.caps.supportsTruecolor()) {
            return .truecolor_24bit;
        } else if (self.caps.supports256Color()) {
            return .extended_256;
        } else {
            return .basic_16;
        }
    }

    /// Set foreground color with automatic capability detection
    pub fn setForegroundColor(self: *TerminalColorManager, r: u8, g: u8, b: u8) ![]u8 {
        const rgb_key = (@as(u32, r) << 16) | (@as(u32, g) << 8) | @as(u32, b);

        // Check cache first
        if (self.color_cache.get(rgb_key)) |cached| {
            return try self.allocator.dupe(u8, cached);
        }

        const sequence = switch (self.getColorCapability()) {
            .truecolor_24bit => try self.formatTruecolorFg(r, g, b),
            .extended_256 => blk: {
                const index = precise_palette.PreciseColorMatcher.convertRgbTo256(.{
                    .r = r,
                    .g = g,
                    .b = b,
                });
                break :blk try self.formatAnsi256Fg(index);
            },
            .basic_16 => blk: {
                const index = precise_palette.PreciseColorMatcher.convertRgbTo16(.{
                    .r = r,
                    .g = g,
                    .b = b,
                });
                break :blk try self.formatBasicFg(index);
            },
            .adaptive => try self.setForegroundColor(r, g, b), // Recursive call with detected capability
        };

        // Cache the result
        try self.color_cache.put(rgb_key, try self.allocator.dupe(u8, sequence));

        return sequence;
    }

    /// Set background color with automatic capability detection
    pub fn setBackgroundColor(self: *TerminalColorManager, r: u8, g: u8, b: u8) ![]u8 {
        const rgb_key = (@as(u32, r) << 16) | (@as(u32, g) << 8) | @as(u32, b);

        // Check cache first
        if (self.color_cache.get(rgb_key)) |cached| {
            return try self.allocator.dupe(u8, cached);
        }

        const sequence = switch (self.getColorCapability()) {
            .truecolor_24bit => try self.formatTruecolorBg(r, g, b),
            .extended_256 => blk: {
                const index = precise_palette.PreciseColorMatcher.convertRgbTo256(.{
                    .r = r,
                    .g = g,
                    .b = b,
                });
                break :blk try self.formatAnsi256Bg(index);
            },
            .basic_16 => blk: {
                const index = precise_palette.PreciseColorMatcher.convertRgbTo16(.{
                    .r = r,
                    .g = g,
                    .b = b,
                });
                break :blk try self.formatBasicBg(index);
            },
            .adaptive => try self.setBackgroundColor(r, g, b), // Recursive call with detected capability
        };

        // Cache the result
        try self.color_cache.put(rgb_key, try self.allocator.dupe(u8, sequence));

        return sequence;
    }

    /// Create gradient between two colors
    pub fn createGradient(self: *TerminalColorManager, start_r: u8, start_g: u8, start_b: u8, end_r: u8, end_g: u8, end_b: u8, steps: u8) ![]u8 {
        if (steps == 0) return error.InvalidSteps;

        var result = std.ArrayList(u8).init(self.allocator);
        errdefer result.deinit();

        const step_count = if (steps == 1) 2 else steps;
        const total_steps = step_count - 1;

        for (0..step_count) |step| {
            const t = @as(f32, @floatFromInt(step)) / @as(f32, @floatFromInt(total_steps));

            // Interpolate RGB values
            const r = @as(u8, @intFromFloat(@as(f32, @floatFromInt(start_r)) * (1.0 - t) + @as(f32, @floatFromInt(end_r)) * t));
            const g = @as(u8, @intFromFloat(@as(f32, @floatFromInt(start_g)) * (1.0 - t) + @as(f32, @floatFromInt(end_g)) * t));
            const b = @as(u8, @intFromFloat(@as(f32, @floatFromInt(start_b)) * (1.0 - t) + @as(f32, @floatFromInt(end_b)) * t));

            const color_seq = try self.setBackgroundColor(r, g, b);
            defer self.allocator.free(color_seq);

            try result.appendSlice(color_seq);
            try result.appendSlice("  "); // Add spacing between gradient steps
        }

        // Reset to default background
        try result.appendSlice("\x1b[49m");

        return try result.toOwnedSlice();
    }

    /// Apply color scheme
    pub fn applyColorScheme(self: *TerminalColorManager, scheme: ColorScheme) ![]u8 {
        var result = std.ArrayList(u8).init(self.allocator);
        errdefer result.deinit();

        // Define color scheme colors inline to avoid struct issues
        const bg_r: u8 = switch (scheme) {
            .dark => 0x1a,
            .light => 0xf8,
            .high_contrast => 0x00,
            .colorblind_friendly => 0xff,
            .custom => return error.NotImplemented,
        };
        const bg_g: u8 = switch (scheme) {
            .dark => 0x1a,
            .light => 0xf8,
            .high_contrast => 0x00,
            .colorblind_friendly => 0xff,
            .custom => return error.NotImplemented,
        };
        const bg_b: u8 = switch (scheme) {
            .dark => 0x1a,
            .light => 0xf8,
            .high_contrast => 0x00,
            .colorblind_friendly => 0xff,
            .custom => return error.NotImplemented,
        };

        const fg_r: u8 = switch (scheme) {
            .dark => 0xe0,
            .light => 0x2a,
            .high_contrast => 0xff,
            .colorblind_friendly => 0x00,
            .custom => return error.NotImplemented,
        };
        const fg_g: u8 = switch (scheme) {
            .dark => 0xe0,
            .light => 0x2a,
            .high_contrast => 0xff,
            .colorblind_friendly => 0x00,
            .custom => return error.NotImplemented,
        };
        const fg_b: u8 = switch (scheme) {
            .dark => 0xe0,
            .light => 0x2a,
            .high_contrast => 0xff,
            .colorblind_friendly => 0x00,
            .custom => return error.NotImplemented,
        };

        const cursor_r: u8 = switch (scheme) {
            .dark => 0xff,
            .light => 0x00,
            .high_contrast => 0xff,
            .colorblind_friendly => 0x00,
            .custom => return error.NotImplemented,
        };
        const cursor_g: u8 = switch (scheme) {
            .dark => 0xff,
            .light => 0x00,
            .high_contrast => 0x00,
            .colorblind_friendly => 0x00,
            .custom => return error.NotImplemented,
        };
        const cursor_b: u8 = switch (scheme) {
            .dark => 0xff,
            .light => 0x00,
            .high_contrast => 0x00,
            .colorblind_friendly => 0xff,
            .custom => return error.NotImplemented,
        };

        // Apply background
        const bg_seq = try self.setBackgroundColor(bg_r, bg_g, bg_b);
        defer self.allocator.free(bg_seq);
        try result.appendSlice(bg_seq);

        // Apply foreground
        const fg_seq = try self.setForegroundColor(fg_r, fg_g, fg_b);
        defer self.allocator.free(fg_seq);
        try result.appendSlice(fg_seq);

        // Apply cursor color
        const cursor_seq = try self.setCursorColor(cursor_r, cursor_g, cursor_b);
        defer self.allocator.free(cursor_seq);
        try result.appendSlice(cursor_seq);

        return try result.toOwnedSlice();
    }

    /// Query current terminal colors
    pub fn queryColors(self: *TerminalColorManager) !struct { fg: ?precise_palette.RGBColor, bg: ?precise_palette.RGBColor } {
        // This would use the terminal query system to get current colors
        // For now, return null as this requires terminal interaction
        return .{ .fg = null, .bg = null };
    }

    /// Reset all colors to terminal defaults
    pub fn resetAllColors(self: *TerminalColorManager) []u8 {
        return "\x1b[0m"; // Reset all attributes
    }

    /// Format truecolor foreground sequence
    fn formatTruecolorFg(self: *TerminalColorManager, r: u8, g: u8, b: u8) ![]u8 {
        return try std.fmt.allocPrint(self.allocator, "\x1b[38;2;{};{};{}m", .{ r, g, b });
    }

    /// Format truecolor background sequence
    fn formatTruecolorBg(self: *TerminalColorManager, r: u8, g: u8, b: u8) ![]u8 {
        return try std.fmt.allocPrint(self.allocator, "\x1b[48;2;{};{};{}m", .{ r, g, b });
    }

    /// Format ANSI 256 foreground sequence
    fn formatAnsi256Fg(self: *TerminalColorManager, index: u8) ![]u8 {
        return try std.fmt.allocPrint(self.allocator, "\x1b[38;5;{}m", .{index});
    }

    /// Format ANSI 256 background sequence
    fn formatAnsi256Bg(self: *TerminalColorManager, index: u8) ![]u8 {
        return try std.fmt.allocPrint(self.allocator, "\x1b[48;5;{}m", .{index});
    }

    /// Format basic ANSI foreground sequence
    fn formatBasicFg(self: *TerminalColorManager, index: u8) ![]u8 {
        if (index <= 7) {
            return try std.fmt.allocPrint(self.allocator, "\x1b[{}m", .{30 + index});
        } else {
            return try std.fmt.allocPrint(self.allocator, "\x1b[{}m", .{90 + (index - 8)});
        }
    }

    /// Format basic ANSI background sequence
    fn formatBasicBg(self: *TerminalColorManager, index: u8) ![]u8 {
        if (index <= 7) {
            return try std.fmt.allocPrint(self.allocator, "\x1b[{}m", .{40 + index});
        } else {
            return try std.fmt.allocPrint(self.allocator, "\x1b[{}m", .{100 + (index - 8)});
        }
    }

    /// Set cursor color
    fn setCursorColor(self: *TerminalColorManager, r: u8, g: u8, b: u8) ![]u8 {
        // OSC 12 for cursor color
        return try std.fmt.allocPrint(self.allocator, "\x1b]12;#{:0>6x}\x07", .{
            (@as(u32, r) << 16) | (@as(u32, g) << 8) | @as(u32, b)
        });
    }
};</xai:function_call name="read">
