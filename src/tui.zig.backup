//! Terminal User Interface framework for DocZ - Clean minimal version for partial rendering
const std = @import("std");
const print = std.debug.print;

// Import terminal capabilities
const caps_mod = @import("term/caps.zig");
const mode = @import("term/ansi/mode.zig");
pub const TermCaps = caps_mod.TermCaps;

/// Mouse event types
pub const MouseEvent = struct {
    pub const Button = enum(u8) {
        left = 0,
        middle = 1,
        right = 2,
        scroll_up = 64,
        scroll_down = 65,
    };

    pub const Action = enum {
        press,
        release,
        drag,
        scroll,
    };

    button: Button,
    action: Action,
    x: u32,
    y: u32,
    modifiers: struct {
        ctrl: bool = false,
        shift: bool = false,
        alt: bool = false,
    },
};

/// Mouse event handler function type
pub const MouseHandler = fn (event: MouseEvent) void;

/// ANSI color codes for styling
pub const Color = struct {
    pub const RESET = "\x1b[0m";
    pub const BOLD = "\x1b[1m";
    pub const DIM = "\x1b[2m";
    pub const BRIGHT_BLUE = "\x1b[94m";
    pub const BRIGHT_RED = "\x1b[91m";
    pub const BRIGHT_YELLOW = "\x1b[93m";
    pub const BRIGHT_CYAN = "\x1b[96m";
    pub const WHITE = "\x1b[37m";
    pub const BG_BLUE = "\x1b[44m";
};

/// Box drawing characters for borders
pub const Box = struct {
    pub const HORIZONTAL = "─";
    pub const VERTICAL = "│";
    pub const TOP_LEFT = "┌";
    pub const TOP_RIGHT = "┐";
    pub const BOTTOM_LEFT = "└";
    pub const BOTTOM_RIGHT = "┘";
};

/// Status icons for various UI states
pub const Status = struct {
    pub const LOADING = "⏳";
    pub const GEAR = "⚙️";
    pub const LINK = "🔗";
    pub const BROWSER = "🌐";
    pub const WAITING = "⏱️";
    pub const INFO = "ℹ️";
    pub const SHIELD = "🛡️";
    pub const SUCCESS = "✅";
    pub const ERROR = "❌";
};

/// Progress bar component for visual progress indication
pub const ProgressBar = struct {
    value: f32,
    total_value: f32,
    width: u32,
    style: Style,
    show_percentage: bool,

    pub const Style = enum {
        ascii, // Simple ASCII [####----]
        unicode, // Unicode blocks ▓▓▓░░░
        gradient, // Color gradient (when supported)
    };

    pub fn init(width: u32, total: f32) ProgressBar {
        return ProgressBar{
            .value = 0.0,
            .total_value = total,
            .width = width,
            .style = .unicode,
            .show_percentage = true,
        };
    }

    pub fn update(self: *ProgressBar, new_value: f32) void {
        self.value = @min(new_value, self.total_value);
    }

    pub fn setProgress(self: *ProgressBar, progress: f32) void {
        self.value = progress * self.total_value;
    }

    pub fn getProgress(self: ProgressBar) f32 {
        if (self.total_value == 0.0) return 0.0;
        return self.value / self.total_value;
    }

    pub fn draw(self: ProgressBar) void {
        const progress = self.getProgress();
        const filled_width = @as(u32, @intFromFloat(progress * @as(f32, @floatFromInt(self.width))));

        // Use basic terminal capabilities for now
        const caps = TermCaps{
            .supportsTruecolor = true, // Assume modern terminal
            .supportsHyperlinkOsc8 = false,
            .supportsClipboardOsc52 = false,
            .supportsWorkingDirOsc7 = false,
            .supportsTitleOsc012 = false,
            .supportsNotifyOsc9 = false,
            .supportsFinalTermOsc133 = false,
            .supportsITerm2Osc1337 = false,
            .supportsColorOsc10_12 = false,
            .supportsKittyKeyboard = false,
            .supportsKittyGraphics = false,
            .supportsSixel = false,
            .supportsModifyOtherKeys = false,
            .supportsXtwinops = false,
            .supportsBracketedPaste = false,
            .supportsFocusEvents = false,
            .supportsSgrMouse = false,
            .supportsSgrPixelMouse = false,
            .supportsLightDarkReport = false,
            .supportsLinuxPaletteOscP = false,
            .needsTmuxPassthrough = false,
            .needsScreenPassthrough = false,
            .screenChunkLimit = 1000,
            .widthMethod = .wcwidth,
        };

        switch (self.style) {
            .ascii => self.drawAscii(filled_width),
            .unicode => self.drawUnicode(filled_width),
            .gradient => if (caps.supportsTruecolor) {
                self.drawGradient(filled_width, caps);
            } else {
                self.drawUnicode(filled_width);
            },
        }

        if (self.show_percentage) {
            print(" {d:.1}%", .{progress * 100.0});
        }
    }

    fn drawAscii(self: ProgressBar, filled: u32) void {
        print("[", .{});
        var i: u32 = 0;
        while (i < self.width) : (i += 1) {
            if (i < filled) {
                print("#", .{});
            } else {
                print("-", .{});
            }
        }
        print("]", .{});
    }

    fn drawUnicode(self: ProgressBar, filled: u32) void {
        print("[", .{});
        var i: u32 = 0;
        while (i < self.width) : (i += 1) {
            if (i < filled) {
                print("█", .{});
            } else {
                print("░", .{});
            }
        }
        print("]", .{});
    }

    fn drawGradient(self: ProgressBar, filled: u32, caps: TermCaps) void {
        const sgr = @import("term/ansi/sgr.zig");
        var buffer: [1024]u8 = undefined;
        var stream = std.io.fixedBufferStream(&buffer);
        const writer = stream.writer();
        
        print("[", .{});

        var i: u32 = 0;
        while (i < self.width) : (i += 1) {
            // Calculate color based on position
            const ratio = @as(f32, @floatFromInt(i)) / @as(f32, @floatFromInt(self.width));
            const r = @as(u8, @intFromFloat(ratio * 255.0));
            const g = @as(u8, @intFromFloat((1.0 - ratio) * 255.0 + ratio * 100.0));
            const b = @as(u8, @intFromFloat((1.0 - ratio) * 100.0));

            if (i < filled) {
                sgr.setForegroundRgb(writer, caps, r, g, b) catch {};
                print("█", .{});
                const written = stream.getWritten();
                print("{s}", .{written});
                stream.reset();
            } else {
                sgr.resetStyle(writer, caps) catch {};
                const written = stream.getWritten();
                print("{s}", .{written});
                stream.reset();
                print("░", .{});
            }
        }

        // Reset colors
        sgr.resetStyle(writer, caps) catch {};
        const written = stream.getWritten();
        print("{s}", .{written});

        print("]", .{});
    }
};

/// Terminal control sequences
pub const Control = struct {
    pub const CLEAR_SCREEN = "\x1b[2J";
    pub const CLEAR_LINE = "\x1b[2K";
    pub const CURSOR_HOME = "\x1b[H";
};

/// Terminal dimensions
pub const TerminalSize = struct {
    width: u32,
    height: u32,
};

/// Get terminal dimensions
pub fn getTerminalSize() TerminalSize {
    var size = TerminalSize{ .width = 80, .height = 24 };
    if (@import("builtin").os.tag == .linux or @import("builtin").os.tag == .macos) {
        const c = std.c;
        var ws: c.winsize = undefined;
        if (c.ioctl(std.posix.STDOUT_FILENO, c.T.IOCGWINSZ, &ws) == 0) {
            if (ws.col > 0 and ws.row > 0) {
                size.width = ws.col;
                size.height = ws.row;
            }
        }
    }
    return size;
}

/// Parse SGR mouse event from escape sequence
/// Format: ESC[<b;x;yM (press) or ESC[<b;x;ym (release)
pub fn parseSgrMouseEvent(sequence: []const u8) ?MouseEvent {
    if (sequence.len < 6) return null;
    if (sequence[0] != '\x1b' or sequence[1] != '[' or sequence[2] != '<') return null;

    // Find the terminator (M for press, m for release)
    const last_char = sequence[sequence.len - 1];
    const is_press = last_char == 'M';
    const is_release = last_char == 'm';
    if (!is_press and !is_release) return null;

    // Parse the parameters b;x;y
    const param_start: usize = 3;
    const param_end = sequence.len - 1;
    const params_str = sequence[param_start..param_end];

    var params = std.mem.split(u8, params_str, ";");

    // Parse button
    const button_str = params.next() orelse return null;
    const button_code = std.fmt.parseInt(u8, button_str, 10) catch return null;

    // Parse x coordinate
    const x_str = params.next() orelse return null;
    const x = std.fmt.parseInt(u32, x_str, 10) catch return null;

    // Parse y coordinate
    const y_str = params.next() orelse return null;
    const y = std.fmt.parseInt(u32, y_str, 10) catch return null;

    // Determine button and modifiers
    const raw_button = button_code & 0x3;
    const modifiers_mask = button_code >> 2;

    const button: MouseEvent.Button = switch (raw_button) {
        0 => .left,
        1 => .middle,
        2 => .right,
        else => {
            // Handle scroll events (button codes 64, 65)
            if (button_code == 64) return MouseEvent{
                .button = .scroll_up,
                .action = .scroll,
                .x = x,
                .y = y,
                .modifiers = .{
                    .ctrl = (modifiers_mask & 4) != 0,
                    .shift = (modifiers_mask & 1) != 0,
                    .alt = (modifiers_mask & 2) != 0,
                },
            };
            if (button_code == 65) return MouseEvent{
                .button = .scroll_down,
                .action = .scroll,
                .x = x,
                .y = y,
                .modifiers = .{
                    .ctrl = (modifiers_mask & 4) != 0,
                    .shift = (modifiers_mask & 1) != 0,
                    .alt = (modifiers_mask & 2) != 0,
                },
            };
            return null;
        },
    };

    const action: MouseEvent.Action = if (is_press) .press else .release;

    return MouseEvent{
        .button = button,
        .action = action,
        .x = x,
        .y = y,
        .modifiers = .{
            .ctrl = (modifiers_mask & 4) != 0,
            .shift = (modifiers_mask & 1) != 0,
            .alt = (modifiers_mask & 2) != 0,
        },
    };
}

/// Draw a horizontal border line
pub fn drawHorizontalBorder(width: u32, left_char: []const u8, middle_char: []const u8, right_char: []const u8) void {
    print("{s}", .{left_char});
    var i: u32 = 0;
    while (i < width - 2) : (i += 1) {
        print("{s}", .{middle_char});
    }
    print("{s}\n", .{right_char});
}

/// Clear screen and move cursor to home
pub fn clearScreen() void {
    print("{s}{s}", .{ Control.CLEAR_SCREEN, Control.CURSOR_HOME });
}

/// Move cursor to specific position (1-indexed)
pub fn moveCursor(row: u32, col: u32) void {
    print("\x1b[{};{}H", .{ row, col });
}

/// Clear specific number of lines from current cursor position
pub fn clearLines(count: u32) void {
    var i: u32 = 0;
    while (i < count) : (i += 1) {
        print("{s}", .{Control.CLEAR_LINE});
        if (i < count - 1) {
            print("\n", .{});
        }
    }
}

/// Save current cursor position and clear area for component update
pub fn prepareComponentUpdate(start_row: u32, line_count: u32) void {
    moveCursor(start_row, 1);
    clearLines(line_count);
    moveCursor(start_row, 1);
}

/// Simple Screen state manager for efficient partial updates
pub const Screen = struct {
    pub const Component = struct {
        id: []const u8,
        content_hash: u64,
        has_been_drawn: bool,

        pub fn init(id: []const u8) Component {
            return Component{
                .id = id,
                .content_hash = 0,
                .has_been_drawn = false,
            };
        }
    };

    components: std.array_list.Managed(Component),

    pub fn init(allocator: std.mem.Allocator) Screen {
        return Screen{
            .components = std.array_list.Managed(Component).init(allocator),
        };
    }

    pub fn deinit(self: *Screen) void {
        self.components.deinit();
    }

    pub fn findComponent(self: *Screen, id: []const u8) ?*Component {
        for (self.components.items) |*component| {
            if (std.mem.eql(u8, component.id, id)) {
                return component;
            }
        }
        return null;
    }

    pub fn shouldDraw(self: *Screen, id: []const u8, content_hash: u64) bool {
        if (self.findComponent(id)) |component| {
            if (component.has_been_drawn and component.content_hash == content_hash) {
                return false; // Content hasn't changed, skip draw
            }
            // Update hash and mark as drawn
            component.content_hash = content_hash;
            component.has_been_drawn = true;
            return true;
        } else {
            // New component, register it
            const component = Component.init(id);
            self.components.append(component) catch {};
            if (self.findComponent(id)) |new_component| {
                new_component.content_hash = content_hash;
                new_component.has_been_drawn = true;
            }
            return true;
        }
    }
};

/// Global screen state instance
var global_screen: ?Screen = null;

/// Initialize global screen state
pub fn initScreen(allocator: std.mem.Allocator) void {
    global_screen = Screen.init(allocator);
}

/// Get global screen state
pub fn getScreen() ?*Screen {
    if (global_screen) |*screen| {
        return screen;
    }
    return null;
}

/// Cleanup global screen state
pub fn deinitScreen() void {
    if (global_screen) |*screen| {
        screen.deinit();
        global_screen = null;
    }
}

/// Section component with border
pub const Section = struct {
    title: []const u8,
    content: []const []const u8,
    width: u32,

    pub fn init(title: []const u8, content: []const []const u8, width: u32) Section {
        return Section{
            .title = title,
            .content = content,
            .width = width,
        };
    }

    /// Calculate content hash for change detection
    fn calculateHash(self: Section) u64 {
        var hasher = std.hash.Wyhash.init(0);
        hasher.update(self.title);
        for (self.content) |line| {
            hasher.update(line);
        }
        return hasher.final();
    }

    /// Draw section with optional partial update support
    pub fn draw(self: Section) void {
        self.drawWithId(null);
    }

    /// Draw section with component ID for partial updates
    pub fn drawWithId(self: Section, component_id: ?[]const u8) void {
        // Check if we should skip drawing based on content hash
        if (component_id) |id| {
            if (getScreen()) |screen| {
                const content_hash = self.calculateHash();
                if (!screen.shouldDraw(id, content_hash)) {
                    return; // Skip drawing, content hasn't changed
                }
            }
        }

        // Draw the section
        // Top border with title
        print("{s}", .{Box.TOP_LEFT});
        const title_padding = if (self.width > self.title.len + 4) (self.width - self.title.len - 4) / 2 else 0;

        var i: u32 = 0;
        while (i < title_padding) : (i += 1) {
            print("{s}", .{Box.HORIZONTAL});
        }
        print(" {s}{s}{s} ", .{ Color.BOLD, self.title, Color.RESET });

        i = @intCast(title_padding + self.title.len + 2);
        while (i < self.width - 1) : (i += 1) {
            print("{s}", .{Box.HORIZONTAL});
        }
        print("{s}\n", .{Box.TOP_RIGHT});

        // Content
        for (self.content) |line| {
            print("{s} {s}", .{ Box.VERTICAL, line });
            const line_len = line.len;
            const content_width = self.width - 2;
            if (line_len < content_width - 1) {
                const padding_needed = content_width - line_len - 1;
                var j: u32 = 0;
                while (j < padding_needed) : (j += 1) {
                    print(" ", .{});
                }
            }
            print("{s}\n", .{Box.VERTICAL});
        }

        // Bottom border
        drawHorizontalBorder(self.width, Box.BOTTOM_LEFT, Box.HORIZONTAL, Box.BOTTOM_RIGHT);
    }
};

/// Menu component
pub const Menu = struct {
    pub const MenuItem = struct {
        key: []const u8,
        description: []const u8,
        action: []const u8,
    };

    items: []const MenuItem,
    selected: u32,
    bounds: Bounds, // Added bounds for mouse interaction
    title_row: u32, // Track title row for mouse calculations

    pub fn init(items: []const MenuItem, bounds: Bounds) Menu {
        return Menu{
            .items = items,
            .selected = 0,
            .bounds = bounds,
            .title_row = 0,
        };
    }

    pub fn selectNext(self: *Menu) void {
        if (self.items.len > 0) {
            self.selected = (self.selected + 1) % @as(u32, @intCast(self.items.len));
        }
    }

    pub fn selectPrevious(self: *Menu) void {
        if (self.items.len > 0) {
            self.selected = if (self.selected > 0) self.selected - 1 else @as(u32, @intCast(self.items.len - 1));
        }
    }

    pub fn setSelected(self: *Menu, index: u32) void {
        if (index < self.items.len) {
            self.selected = index;
        }
    }

    pub fn draw(self: *Menu, title: []const u8) void {
        self.drawWithId(title, null);
    }

    pub fn drawWithId(self: *Menu, title: []const u8, component_id: ?[]const u8) void {
        // For simplicity, always draw menu (could be optimized later)
        _ = component_id;

        // Position cursor at menu bounds
        moveCursor(self.bounds.y, self.bounds.x);

        // Draw title and track its position
        print("{s}{s}{s}\n", .{ Color.BOLD, title, Color.RESET });
        self.title_row = self.bounds.y;

        // Draw menu items
        for (self.items, 0..) |item, i| {
            const is_selected = i == self.selected;
            const prefix = if (is_selected) "▶ " else "  ";
            const color = if (is_selected) Color.BRIGHT_CYAN else Color.WHITE;

            moveCursor(self.bounds.y + 1 + @as(u32, @intCast(i)), self.bounds.x);
            print("{s}{s}{s}{s}{s} - {s}{s}", .{
                color,
                prefix,
                Color.BOLD,
                item.key,
                Color.RESET,
                Color.DIM,
                item.description,
            });
        }

        // Position for help text
        moveCursor(self.bounds.y + 1 + @as(u32, @intCast(self.items.len)) + 1, self.bounds.x);
        print("{s}Use arrow keys or mouse to navigate, Enter to select{s}", .{ Color.DIM, Color.RESET });
    }

    /// Handle mouse events for the menu
    pub fn handleMouseEvent(self: *Menu, event: MouseEvent) bool {
        // Check if mouse event is within menu bounds (rough estimation)
        const menu_start_y = self.bounds.y + 1; // After title
        const menu_end_y = menu_start_y + @as(u32, @intCast(self.items.len));

        if (event.x < self.bounds.x or event.x >= self.bounds.x + self.bounds.width or
            event.y < menu_start_y or event.y >= menu_end_y)
        {
            return false; // Event not handled
        }

        switch (event.action) {
            .scroll => {
                // Handle mouse wheel scrolling for navigation
                switch (event.button) {
                    .scroll_up => {
                        self.selectPrevious();
                        return true;
                    },
                    .scroll_down => {
                        self.selectNext();
                        return true;
                    },
                    else => {},
                }
            },
            .press => {
                if (event.button == .left) {
                    // Calculate which menu item was clicked
                    const clicked_item = event.y - menu_start_y;
                    if (clicked_item < self.items.len) {
                        self.setSelected(@as(u32, @intCast(clicked_item)));
                        return true;
                    }
                }
            },
            .release, .drag => {
                // Not handling these for now
                return false;
            },
        }

        return false; // Event not handled
    }
};

/// Status bar component
pub const StatusBar = struct {
    left_text: []const u8,
    right_text: []const u8,

    pub fn init(left: []const u8, right: []const u8) StatusBar {
        return StatusBar{
            .left_text = left,
            .right_text = right,
        };
    }

    pub fn draw(self: StatusBar) void {
        self.drawWithId(null);
    }

    pub fn drawWithId(self: StatusBar, component_id: ?[]const u8) void {
        // For simplicity, always draw status bar (could be optimized later)
        _ = component_id;

        const terminal_size = getTerminalSize();
        const width = terminal_size.width;

        // Calculate padding
        const left_len = self.left_text.len;
        const right_len = self.right_text.len;
        const padding = if (width > left_len + right_len) width - left_len - right_len else 0;

        print("{s}{s}{s}", .{ Color.BG_BLUE, Color.WHITE, self.left_text });

        var i: u32 = 0;
        while (i < padding) : (i += 1) {
            print(" ", .{});
        }

        print("{s}{s}\n", .{ self.right_text, Color.RESET });
    }
};

/// Command history manager
pub const CommandHistory = struct {
    entries: std.array_list.Managed([]u8),
    current_index: ?usize,
    max_size: usize,

    pub fn init(allocator: std.mem.Allocator, max_size: usize) CommandHistory {
        return CommandHistory{
            .entries = std.array_list.Managed([]u8).init(allocator),
            .current_index = null,
            .max_size = max_size,
        };
    }

    pub fn deinit(self: *CommandHistory) void {
        for (self.entries.items) |entry| {
            self.entries.allocator.free(entry);
        }
        self.entries.deinit();
    }

    pub fn add(self: *CommandHistory, command: []const u8) !void {
        if (command.len == 0) return;

        // Don't add duplicate of the last command
        if (self.entries.items.len > 0 and std.mem.eql(u8, self.entries.items[self.entries.items.len - 1], command)) {
            return;
        }

        // Remove oldest entry if at max capacity
        if (self.entries.items.len >= self.max_size) {
            self.entries.allocator.free(self.entries.orderedRemove(0));
        }

        const owned_command = try self.entries.allocator.dupe(u8, command);
        try self.entries.append(owned_command);
        self.current_index = null;
    }

    pub fn navigateUp(self: *CommandHistory) ?[]const u8 {
        if (self.entries.items.len == 0) return null;

        if (self.current_index) |idx| {
            if (idx > 0) {
                self.current_index = idx - 1;
                return self.entries.items[idx - 1];
            }
        } else {
            self.current_index = self.entries.items.len - 1;
            return self.entries.items[self.entries.items.len - 1];
        }
        return null;
    }

    pub fn navigateDown(self: *CommandHistory) ?[]const u8 {
        if (self.current_index) |idx| {
            if (idx + 1 < self.entries.items.len) {
                self.current_index = idx + 1;
                return self.entries.items[idx + 1];
            } else {
                self.current_index = null;
                return "";
            }
        }
        return null;
    }

    pub fn resetNavigation(self: *CommandHistory) void {
        self.current_index = null;
    }
};

/// Tab completion helper
pub fn findCompletions(prefix: []const u8, commands: []const []const u8, allocator: std.mem.Allocator) ![][]const u8 {
    var matches = std.array_list.Managed([]const u8).init(allocator);
    defer matches.deinit();

    for (commands) |command| {
        if (std.mem.startsWith(u8, command, prefix)) {
            try matches.append(command);
        }
    }

    return matches.toOwnedSlice();
}

/// Rectangle bounds for layout positioning
pub const Bounds = struct {
    x: u32,
    y: u32,
    width: u32,
    height: u32,

    pub fn init(x: u32, y: u32, width: u32, height: u32) Bounds {
        return Bounds{ .x = x, .y = y, .width = width, .height = height };
    }

    pub fn contains(self: Bounds, x: u32, y: u32) bool {
        return x >= self.x and x < self.x + self.width and
            y >= self.y and y < self.y + self.height;
    }

    pub fn intersects(self: Bounds, other: Bounds) bool {
        return self.x < other.x + other.width and
            self.x + self.width > other.x and
            self.y < other.y + other.height and
            self.y + self.height > other.y;
    }
};

/// Layout direction for flexbox-style layouts
pub const Direction = enum {
    row,
    column,
};

/// Layout alignment options
pub const Alignment = enum {
    start,
    center,
    end,
    stretch,
};

/// Layout size constraints
pub const Size = union(enum) {
    auto: void,
    fixed: u32,
    percentage: f32,
    fill: void,
};

/// Layout container for organizing components
pub const Layout = struct {
    direction: Direction,
    bounds: Bounds,
    padding: u32,
    gap: u32,
    alignment: Alignment,
    children: std.array_list.Managed(LayoutItem),

    const LayoutItem = struct {
        size: Size,
        min_width: ?u32,
        min_height: ?u32,
        max_width: ?u32,
        max_height: ?u32,
        computed_bounds: Bounds,
    };

    pub fn init(allocator: std.mem.Allocator, direction: Direction, bounds: Bounds) Layout {
        return Layout{
            .direction = direction,
            .bounds = bounds,
            .padding = 0,
            .gap = 0,
            .alignment = .start,
            .children = std.array_list.Managed(LayoutItem).init(allocator),
        };
    }

    pub fn deinit(self: *Layout) void {
        self.children.deinit();
    }

    pub fn setPadding(self: *Layout, padding: u32) void {
        self.padding = padding;
    }

    pub fn setGap(self: *Layout, gap: u32) void {
        self.gap = gap;
    }

    pub fn setAlignment(self: *Layout, alignment: Alignment) void {
        self.alignment = alignment;
    }

    pub fn addChild(self: *Layout, size: Size) !usize {
        const item = LayoutItem{
            .size = size,
            .min_width = null,
            .min_height = null,
            .max_width = null,
            .max_height = null,
            .computed_bounds = Bounds.init(0, 0, 0, 0),
        };
        try self.children.append(item);
        return self.children.items.len - 1;
    }

    pub fn setConstraints(self: *Layout, index: usize, min_width: ?u32, min_height: ?u32, max_width: ?u32, max_height: ?u32) void {
        if (index < self.children.items.len) {
            self.children.items[index].min_width = min_width;
            self.children.items[index].min_height = min_height;
            self.children.items[index].max_width = max_width;
            self.children.items[index].max_height = max_height;
        }
    }

    pub fn layout(self: *Layout) void {
        const content_bounds = Bounds.init(
            self.bounds.x + self.padding,
            self.bounds.y + self.padding,
            if (self.bounds.width > 2 * self.padding) self.bounds.width - 2 * self.padding else 0,
            if (self.bounds.height > 2 * self.padding) self.bounds.height - 2 * self.padding else 0,
        );

        if (self.children.items.len == 0) return;

        // Calculate total gap space
        const total_gap = if (self.children.items.len > 1) self.gap * @as(u32, @intCast(self.children.items.len - 1)) else 0;

        switch (self.direction) {
            .row => self.layoutRow(content_bounds, total_gap),
            .column => self.layoutColumn(content_bounds, total_gap),
        }
    }

    fn layoutRow(self: *Layout, content_bounds: Bounds, total_gap: u32) void {
        const available_width = if (content_bounds.width > total_gap) content_bounds.width - total_gap else 0;
        var x = content_bounds.x;
        const y = content_bounds.y;
        const height = content_bounds.height;

        // Calculate sizes
        var fixed_width: u32 = 0;
        var fill_count: u32 = 0;

        for (self.children.items) |*child| {
            switch (child.size) {
                .fixed => |w| fixed_width += w,
                .percentage => |pct| fixed_width += @as(u32, @intFromFloat(@as(f32, @floatFromInt(available_width)) * pct)),
                .fill => fill_count += 1,
                .auto => {}, // Will be calculated based on content
            }
        }

        const remaining_width = if (available_width > fixed_width) available_width - fixed_width else 0;
        const fill_width = if (fill_count > 0) remaining_width / fill_count else 0;

        // Position children
        for (self.children.items) |*child| {
            var child_width: u32 = 0;
            switch (child.size) {
                .fixed => |w| child_width = w,
                .percentage => |pct| child_width = @as(u32, @intFromFloat(@as(f32, @floatFromInt(available_width)) * pct)),
                .fill => child_width = fill_width,
                .auto => child_width = @min(remaining_width, 20), // Default auto size
            }

            // Apply constraints
            if (child.min_width) |min_w| child_width = @max(child_width, min_w);
            if (child.max_width) |max_w| child_width = @min(child_width, max_w);

            child.computed_bounds = Bounds.init(x, y, child_width, height);
            x += child_width + self.gap;
        }
    }

    fn layoutColumn(self: *Layout, content_bounds: Bounds, total_gap: u32) void {
        const available_height = if (content_bounds.height > total_gap) content_bounds.height - total_gap else 0;
        const x = content_bounds.x;
        var y = content_bounds.y;
        const width = content_bounds.width;

        // Calculate sizes
        var fixed_height: u32 = 0;
        var fill_count: u32 = 0;

        for (self.children.items) |*child| {
            switch (child.size) {
                .fixed => |h| fixed_height += h,
                .percentage => |pct| fixed_height += @as(u32, @intFromFloat(@as(f32, @floatFromInt(available_height)) * pct)),
                .fill => fill_count += 1,
                .auto => {}, // Will be calculated based on content
            }
        }

        const remaining_height = if (available_height > fixed_height) available_height - fixed_height else 0;
        const fill_height = if (fill_count > 0) remaining_height / fill_count else 0;

        // Position children
        for (self.children.items) |*child| {
            var child_height: u32 = 0;
            switch (child.size) {
                .fixed => |h| child_height = h,
                .percentage => |pct| child_height = @as(u32, @intFromFloat(@as(f32, @floatFromInt(available_height)) * pct)),
                .fill => child_height = fill_height,
                .auto => child_height = @min(remaining_height, 5), // Default auto size
            }

            // Apply constraints
            if (child.min_height) |min_h| child_height = @max(child_height, min_h);
            if (child.max_height) |max_h| child_height = @min(child_height, max_h);

            child.computed_bounds = Bounds.init(x, y, width, child_height);
            y += child_height + self.gap;
        }
    }

    pub fn getChildBounds(self: Layout, index: usize) ?Bounds {
        if (index < self.children.items.len) {
            return self.children.items[index].computed_bounds;
        }
        return null;
    }
};

/// Advanced text input widget with cursor management
pub const TextInput = struct {
    content: std.array_list.Managed(u8),
    cursor_pos: usize,
    selection_start: ?usize,
    selection_end: ?usize,
    bounds: Bounds,
    placeholder: []const u8,
    is_password: bool,
    is_multiline: bool,
    scroll_offset: usize,
    max_length: ?usize,
    is_focused: bool,

    pub fn init(allocator: std.mem.Allocator, bounds: Bounds) TextInput {
        return TextInput{
            .content = std.array_list.Managed(u8).init(allocator),
            .cursor_pos = 0,
            .selection_start = null,
            .selection_end = null,
            .bounds = bounds,
            .placeholder = "",
            .is_password = false,
            .is_multiline = false,
            .scroll_offset = 0,
            .max_length = null,
            .is_focused = false,
        };
    }

    pub fn deinit(self: *TextInput) void {
        self.content.deinit();
    }

    pub fn setPlaceholder(self: *TextInput, placeholder: []const u8) void {
        self.placeholder = placeholder;
    }

    pub fn setPassword(self: *TextInput, is_password: bool) void {
        self.is_password = is_password;
    }

    pub fn setMultiline(self: *TextInput, is_multiline: bool) void {
        self.is_multiline = is_multiline;
    }

    pub fn setMaxLength(self: *TextInput, max_length: ?usize) void {
        self.max_length = max_length;
    }

    pub fn focus(self: *TextInput) void {
        self.is_focused = true;
    }

    pub fn blur(self: *TextInput) void {
        self.is_focused = false;
        self.clearSelection();
    }

    pub fn getText(self: TextInput) []const u8 {
        return self.content.items;
    }

    pub fn setText(self: *TextInput, text: []const u8) !void {
        self.content.clearAndFree();
        try self.content.appendSlice(text);
        self.cursor_pos = @min(self.cursor_pos, self.content.items.len);
        self.clearSelection();
    }

    pub fn insertChar(self: *TextInput, ch: u8) !void {
        if (self.max_length) |max| {
            if (self.content.items.len >= max) return;
        }

        try self.content.insert(self.cursor_pos, ch);
        self.cursor_pos += 1;
        self.clearSelection();
    }

    pub fn deleteChar(self: *TextInput) void {
        if (self.cursor_pos > 0 and self.content.items.len > 0) {
            _ = self.content.orderedRemove(self.cursor_pos - 1);
            self.cursor_pos -= 1;
        }
        self.clearSelection();
    }

    pub fn deleteForward(self: *TextInput) void {
        if (self.cursor_pos < self.content.items.len) {
            _ = self.content.orderedRemove(self.cursor_pos);
        }
        self.clearSelection();
    }

    pub fn moveCursorLeft(self: *TextInput) void {
        if (self.cursor_pos > 0) {
            self.cursor_pos -= 1;
        }
    }

    pub fn moveCursorRight(self: *TextInput) void {
        if (self.cursor_pos < self.content.items.len) {
            self.cursor_pos += 1;
        }
    }

    pub fn moveCursorHome(self: *TextInput) void {
        self.cursor_pos = 0;
    }

    pub fn moveCursorEnd(self: *TextInput) void {
        self.cursor_pos = self.content.items.len;
    }

    pub fn selectAll(self: *TextInput) void {
        if (self.content.items.len > 0) {
            self.selection_start = 0;
            self.selection_end = self.content.items.len;
        }
    }

    pub fn clearSelection(self: *TextInput) void {
        self.selection_start = null;
        self.selection_end = null;
    }

    pub fn deleteSelection(self: *TextInput) void {
        if (self.selection_start) |start| {
            if (self.selection_end) |end| {
                const actual_start = @min(start, end);
                const actual_end = @max(start, end);

                // Remove selected text
                var i = actual_end;
                while (i > actual_start) : (i -= 1) {
                    _ = self.content.orderedRemove(i - 1);
                }

                self.cursor_pos = actual_start;
                self.clearSelection();
            }
        }
    }

    pub fn getDisplayText(self: TextInput) []const u8 {
        if (self.is_password) {
            // Would return masked text in real implementation
            return self.content.items; // For now, return actual text
        }
        return self.content.items;
    }

    pub fn draw(self: *TextInput) void {
        moveCursor(self.bounds.y + 1, self.bounds.x + 1);

        // Draw border
        self.drawBorder();

        // Draw content
        const display_text = self.getDisplayText();
        const visible_text = self.getVisibleText(display_text);

        // Position cursor inside the input field
        moveCursor(self.bounds.y + 1, self.bounds.x + 2);

        if (visible_text.len == 0 and !self.is_focused) {
            // Show placeholder
            print("{s}{s}{s}", .{ Color.DIM, self.placeholder, Color.RESET });
        } else {
            // Show actual text
            print("{s}", .{visible_text});

            // Show cursor if focused
            if (self.is_focused) {
                const cursor_x = self.bounds.x + 2 + @as(u32, @intCast(self.getCursorDisplayPos()));
                moveCursor(self.bounds.y + 1, cursor_x);
                print("{s}│{s}", .{ Color.BRIGHT_CYAN, Color.RESET });
            }
        }
    }

    fn drawBorder(self: TextInput) void {
        const style = if (self.is_focused) Color.BRIGHT_CYAN else Color.WHITE;

        // Top border
        moveCursor(self.bounds.y, self.bounds.x);
        print("{s}{s}", .{ style, Box.TOP_LEFT });
        for (0..self.bounds.width - 2) |_| {
            print("{s}", .{Box.HORIZONTAL});
        }
        print("{s}{s}", .{ Box.TOP_RIGHT, Color.RESET });

        // Bottom border
        moveCursor(self.bounds.y + self.bounds.height - 1, self.bounds.x);
        print("{s}{s}", .{ style, Box.BOTTOM_LEFT });
        for (0..self.bounds.width - 2) |_| {
            print("{s}", .{Box.HORIZONTAL});
        }
        print("{s}{s}", .{ Box.BOTTOM_RIGHT, Color.RESET });

        // Side borders
        for (1..self.bounds.height - 1) |row| {
            moveCursor(self.bounds.y + @as(u32, @intCast(row)), self.bounds.x);
            print("{s}{s}", .{ style, Box.VERTICAL });
            moveCursor(self.bounds.y + @as(u32, @intCast(row)), self.bounds.x + self.bounds.width - 1);
            print("{s}{s}", .{ Box.VERTICAL, Color.RESET });
        }
    }

    fn getVisibleText(self: TextInput, text: []const u8) []const u8 {
        const content_width = if (self.bounds.width > 4) self.bounds.width - 4 else 0;
        if (text.len <= content_width) {
            return text;
        }

        // Implement horizontal scrolling based on cursor position
        const start_pos = if (self.cursor_pos > content_width) self.cursor_pos - content_width else 0;
        const end_pos = @min(start_pos + content_width, text.len);

        return text[start_pos..end_pos];
    }

    fn getCursorDisplayPos(self: TextInput) usize {
        const content_width = if (self.bounds.width > 4) self.bounds.width - 4 else 0;
        if (self.cursor_pos <= content_width) {
            return self.cursor_pos;
        }
        return content_width;
    }
};

/// Scrollable panel widget for displaying lists and content
pub const ScrollablePanel = struct {
    items: std.array_list.Managed([]const u8),
    bounds: Bounds,
    scroll_offset: usize,
    selected_index: ?usize,
    title: []const u8,
    show_scrollbar: bool,
    show_line_numbers: bool,

    pub fn init(allocator: std.mem.Allocator, bounds: Bounds) ScrollablePanel {
        return ScrollablePanel{
            .items = std.array_list.Managed([]const u8).init(allocator),
            .bounds = bounds,
            .scroll_offset = 0,
            .selected_index = null,
            .title = "",
            .show_scrollbar = true,
            .show_line_numbers = false,
        };
    }

    pub fn deinit(self: *ScrollablePanel) void {
        for (self.items.items) |item| {
            self.items.allocator.free(item);
        }
        self.items.deinit();
    }

    pub fn setTitle(self: *ScrollablePanel, title: []const u8) void {
        self.title = title;
    }

    pub fn showScrollbar(self: *ScrollablePanel, show: bool) void {
        self.show_scrollbar = show;
    }

    pub fn showLineNumbers(self: *ScrollablePanel, show: bool) void {
        self.show_line_numbers = show;
    }

    pub fn addItem(self: *ScrollablePanel, item: []const u8) !void {
        const owned_item = try self.items.allocator.dupe(u8, item);
        try self.items.append(owned_item);
    }

    pub fn clearItems(self: *ScrollablePanel) void {
        for (self.items.items) |item| {
            self.items.allocator.free(item);
        }
        self.items.clearAndFree();
        self.scroll_offset = 0;
        self.selected_index = null;
    }

    pub fn setSelectedIndex(self: *ScrollablePanel, index: ?usize) void {
        if (index) |idx| {
            if (idx < self.items.items.len) {
                self.selected_index = idx;
                self.ensureSelectionVisible();
            }
        } else {
            self.selected_index = null;
        }
    }

    pub fn selectNext(self: *ScrollablePanel) void {
        if (self.items.items.len == 0) return;

        if (self.selected_index) |idx| {
            if (idx + 1 < self.items.items.len) {
                self.selected_index = idx + 1;
            }
        } else {
            self.selected_index = 0;
        }
        self.ensureSelectionVisible();
    }

    pub fn selectPrevious(self: *ScrollablePanel) void {
        if (self.items.items.len == 0) return;

        if (self.selected_index) |idx| {
            if (idx > 0) {
                self.selected_index = idx - 1;
            }
        } else {
            self.selected_index = if (self.items.items.len > 0) self.items.items.len - 1 else null;
        }
        self.ensureSelectionVisible();
    }

    pub fn scrollUp(self: *ScrollablePanel) void {
        if (self.scroll_offset > 0) {
            self.scroll_offset -= 1;
        }
    }

    pub fn scrollDown(self: *ScrollablePanel) void {
        const max_scroll = self.getMaxScrollOffset();
        if (self.scroll_offset < max_scroll) {
            self.scroll_offset += 1;
        }
    }

    pub fn pageUp(self: *ScrollablePanel) void {
        const page_size = self.getVisibleItemCount();
        if (self.scroll_offset > page_size) {
            self.scroll_offset -= page_size;
        } else {
            self.scroll_offset = 0;
        }
    }

    pub fn pageDown(self: *ScrollablePanel) void {
        const page_size = self.getVisibleItemCount();
        const max_scroll = self.getMaxScrollOffset();
        self.scroll_offset = @min(self.scroll_offset + page_size, max_scroll);
    }

    pub fn draw(self: *ScrollablePanel) void {
        self.drawBorder();
        self.drawContent();
        if (self.show_scrollbar) {
            self.drawScrollbar();
        }
    }

    /// Handle mouse events for the scrollable panel
    pub fn handleMouseEvent(self: *ScrollablePanel, event: MouseEvent) bool {
        // Check if mouse event is within panel bounds
        if (event.x < self.bounds.x or event.x >= self.bounds.x + self.bounds.width or
            event.y < self.bounds.y or event.y >= self.bounds.y + self.bounds.height)
        {
            return false; // Event not handled
        }

        switch (event.action) {
            .scroll => {
                // Handle mouse wheel scrolling
                switch (event.button) {
                    .scroll_up => {
                        if (event.modifiers.shift) {
                            // Shift+scroll for horizontal scrolling (not implemented)
                        } else if (event.modifiers.ctrl) {
                            // Ctrl+scroll for page scrolling
                            self.pageUp();
                        } else {
                            // Normal scroll up
                            self.scrollUp();
                            self.scrollUp(); // Scroll 2 lines for better UX
                            self.scrollUp();
                        }
                        return true;
                    },
                    .scroll_down => {
                        if (event.modifiers.shift) {
                            // Shift+scroll for horizontal scrolling (not implemented)
                        } else if (event.modifiers.ctrl) {
                            // Ctrl+scroll for page scrolling
                            self.pageDown();
                        } else {
                            // Normal scroll down
                            self.scrollDown();
                            self.scrollDown(); // Scroll 3 lines for better UX
                            self.scrollDown();
                        }
                        return true;
                    },
                    else => {},
                }
            },
            .press => {
                if (event.button == .left) {
                    // Handle left click for item selection
                    const content_y_start = self.bounds.y + 1; // After top border
                    const content_y_end = self.bounds.y + self.bounds.height - 2; // Before bottom border

                    if (event.y >= content_y_start and event.y < content_y_end) {
                        // Calculate which item was clicked
                        const relative_y = event.y - content_y_start;
                        const clicked_item_index = self.scroll_offset + relative_y;

                        if (clicked_item_index < self.items.items.len) {
                            self.setSelectedIndex(clicked_item_index);
                            return true;
                        }
                    }

                    // Handle scrollbar clicks
                    if (self.show_scrollbar and event.x == self.bounds.x + self.bounds.width - 2) {
                        const scrollbar_start_y = self.bounds.y + 1;
                        const scrollbar_end_y = self.bounds.y + self.bounds.height - 2;
                        const scrollbar_height = scrollbar_end_y - scrollbar_start_y;

                        if (event.y >= scrollbar_start_y and event.y < scrollbar_end_y) {
                            // Calculate scroll position based on click position
                            const relative_click = event.y - scrollbar_start_y;
                            const scroll_ratio = @as(f32, @floatFromInt(relative_click)) / @as(f32, @floatFromInt(scrollbar_height));
                            const max_scroll = self.getMaxScrollOffset();
                            const new_scroll = @as(usize, @intFromFloat(scroll_ratio * @as(f32, @floatFromInt(max_scroll))));
                            self.scroll_offset = @min(new_scroll, max_scroll);
                            return true;
                        }
                    }
                }
            },
            .release, .drag => {
                // Could implement drag scrolling in the future
                return false;
            },
        }

        return false; // Event not handled
    }

    fn drawBorder(self: ScrollablePanel) void {
        // Top border with title
        moveCursor(self.bounds.y, self.bounds.x);
        print("{s}", .{Box.TOP_LEFT});

        if (self.title.len > 0) {
            const title_space = self.bounds.width - 4;
            const title_len = @min(self.title.len, title_space);
            const padding = (title_space - title_len) / 2;

            for (0..padding) |_| print("{s}", .{Box.HORIZONTAL});
            print(" {s}{s}{s} ", .{ Color.BOLD, self.title[0..title_len], Color.RESET });
            for (0..title_space - title_len - padding) |_| print("{s}", .{Box.HORIZONTAL});
        } else {
            for (0..self.bounds.width - 2) |_| print("{s}", .{Box.HORIZONTAL});
        }
        print("{s}", .{Box.TOP_RIGHT});

        // Side borders
        for (1..self.bounds.height - 1) |row| {
            moveCursor(self.bounds.y + @as(u32, @intCast(row)), self.bounds.x);
            print("{s}", .{Box.VERTICAL});
            moveCursor(self.bounds.y + @as(u32, @intCast(row)), self.bounds.x + self.bounds.width - 1);
            print("{s}", .{Box.VERTICAL});
        }

        // Bottom border
        moveCursor(self.bounds.y + self.bounds.height - 1, self.bounds.x);
        print("{s}", .{Box.BOTTOM_LEFT});
        for (0..self.bounds.width - 2) |_| print("{s}", .{Box.HORIZONTAL});
        print("{s}", .{Box.BOTTOM_RIGHT});
    }

    fn drawContent(self: ScrollablePanel) void {
        const content_height = self.getVisibleItemCount();
        const content_width = self.getContentWidth();
        const line_num_width = if (self.show_line_numbers) self.getLineNumberWidth() else 0;

        for (0..content_height) |row| {
            const item_index = self.scroll_offset + row;
            moveCursor(self.bounds.y + 1 + @as(u32, @intCast(row)), self.bounds.x + 1);

            if (item_index < self.items.items.len) {
                const item = self.items.items[item_index];
                const is_selected = if (self.selected_index) |sel| sel == item_index else false;

                if (is_selected) {
                    print("{s}", .{Color.BG_BLUE});
                }

                // Line number
                if (self.show_line_numbers) {
                    print("{s}{:>{}}{s} ", .{ Color.DIM, item_index + 1, line_num_width, Color.RESET });
                }

                // Content
                const display_text = if (item.len > content_width - line_num_width - 1)
                    item[0 .. content_width - line_num_width - 1]
                else
                    item;
                print("{s}", .{display_text});

                // Clear to end of line and reset colors
                const remaining_width = content_width - display_text.len - line_num_width - 1;
                for (0..remaining_width) |_| print(" ");

                if (is_selected) {
                    print("{s}", .{Color.RESET});
                }
            } else {
                // Empty line
                for (0..content_width) |_| print(" ");
            }
        }
    }

    fn drawScrollbar(self: ScrollablePanel) void {
        if (self.items.items.len <= self.getVisibleItemCount()) {
            return; // No scrolling needed
        }

        const scrollbar_height = self.bounds.height - 2;
        const thumb_height = @max(1, (scrollbar_height * self.getVisibleItemCount()) / @as(u32, @intCast(self.items.items.len)));
        const thumb_pos = (self.scroll_offset * scrollbar_height) / @as(u32, @intCast(self.items.items.len));

        for (0..scrollbar_height) |row| {
            moveCursor(self.bounds.y + 1 + @as(u32, @intCast(row)), self.bounds.x + self.bounds.width - 2);
            if (row >= thumb_pos and row < thumb_pos + thumb_height) {
                print("{s}█{s}", .{ Color.BRIGHT_BLUE, Color.RESET });
            } else {
                print("{s}░{s}", .{ Color.DIM, Color.RESET });
            }
        }
    }

    fn ensureSelectionVisible(self: *ScrollablePanel) void {
        if (self.selected_index) |idx| {
            const visible_count = self.getVisibleItemCount();

            if (idx < self.scroll_offset) {
                self.scroll_offset = idx;
            } else if (idx >= self.scroll_offset + visible_count) {
                self.scroll_offset = idx - visible_count + 1;
            }
        }
    }

    fn getVisibleItemCount(self: ScrollablePanel) usize {
        return if (self.bounds.height > 2) self.bounds.height - 2 else 0;
    }

    fn getContentWidth(self: ScrollablePanel) usize {
        const scrollbar_width = if (self.show_scrollbar) 1 else 0;
        return if (self.bounds.width > 2 + scrollbar_width)
            self.bounds.width - 2 - scrollbar_width
        else
            0;
    }

    fn getLineNumberWidth(self: ScrollablePanel) usize {
        if (self.items.items.len == 0) return 0;
        const max_line = self.items.items.len;
        if (max_line < 10) return 1;
        if (max_line < 100) return 2;
        if (max_line < 1000) return 3;
        return 4;
    }

    fn getMaxScrollOffset(self: ScrollablePanel) usize {
        const visible_count = self.getVisibleItemCount();
        return if (self.items.items.len > visible_count)
            self.items.items.len - visible_count
        else
            0;
    }
};

/// Column definition for interactive tables
pub const TableColumn = struct {
    name: []const u8,
    width: u32,
    alignment: Alignment,

    pub fn init(name: []const u8, width: u32) TableColumn {
        return TableColumn{
            .name = name,
            .width = width,
            .alignment = .start,
        };
    }

    pub fn withAlignment(name: []const u8, width: u32, alignment: Alignment) TableColumn {
        return TableColumn{
            .name = name,
            .width = width,
            .alignment = alignment,
        };
    }
};

/// Table row data
pub const TableRow = struct {
    cells: std.array_list.Managed([]const u8),
    is_selectable: bool,
    data: ?*anyopaque, // Optional user data pointer

    pub fn init(allocator: std.mem.Allocator) TableRow {
        return TableRow{
            .cells = std.array_list.Managed([]const u8).init(allocator),
            .is_selectable = true,
            .data = null,
        };
    }

    pub fn deinit(self: *TableRow) void {
        for (self.cells.items) |cell| {
            self.cells.allocator.free(cell);
        }
        self.cells.deinit();
    }

    pub fn addCell(self: *TableRow, content: []const u8) !void {
        const owned_content = try self.cells.allocator.dupe(u8, content);
        try self.cells.append(owned_content);
    }

    pub fn setData(self: *TableRow, data: ?*anyopaque) void {
        self.data = data;
    }
};

/// Interactive table widget with selection and data display
pub const InteractiveTable = struct {
    columns: std.array_list.Managed(TableColumn),
    rows: std.array_list.Managed(TableRow),
    bounds: Bounds,
    selected_row: ?usize,
    selected_col: ?usize,
    scroll_offset: usize,
    title: []const u8,
    show_headers: bool,
    show_grid: bool,
    show_row_numbers: bool,
    allow_column_selection: bool,
    sort_column: ?usize,
    sort_ascending: bool,

    pub fn init(allocator: std.mem.Allocator, bounds: Bounds) InteractiveTable {
        return InteractiveTable{
            .columns = std.array_list.Managed(TableColumn).init(allocator),
            .rows = std.array_list.Managed(TableRow).init(allocator),
            .bounds = bounds,
            .selected_row = null,
            .selected_col = null,
            .scroll_offset = 0,
            .title = "",
            .show_headers = true,
            .show_grid = true,
            .show_row_numbers = false,
            .allow_column_selection = false,
            .sort_column = null,
            .sort_ascending = true,
        };
    }

    pub fn deinit(self: *InteractiveTable) void {
        for (self.rows.items) |*row| {
            row.deinit();
        }
        self.columns.deinit();
        self.rows.deinit();
    }

    pub fn setTitle(self: *InteractiveTable, title: []const u8) void {
        self.title = title;
    }

    pub fn showHeaders(self: *InteractiveTable, show: bool) void {
        self.show_headers = show;
    }

    pub fn showGrid(self: *InteractiveTable, show: bool) void {
        self.show_grid = show;
    }

    pub fn showRowNumbers(self: *InteractiveTable, show: bool) void {
        self.show_row_numbers = show;
    }

    pub fn allowColumnSelection(self: *InteractiveTable, allow: bool) void {
        self.allow_column_selection = allow;
    }

    pub fn addColumn(self: *InteractiveTable, column: TableColumn) !void {
        try self.columns.append(column);
    }

    pub fn addRow(self: *InteractiveTable, row: TableRow) !void {
        try self.rows.append(row);
    }

    pub fn clearRows(self: *InteractiveTable) void {
        for (self.rows.items) |*row| {
            row.deinit();
        }
        self.rows.clearAndFree();
        self.selected_row = null;
        self.scroll_offset = 0;
    }

    pub fn setSelectedRow(self: *InteractiveTable, row: ?usize) void {
        if (row) |r| {
            if (r < self.rows.items.len and self.rows.items[r].is_selectable) {
                self.selected_row = r;
                self.ensureRowVisible(r);
            }
        } else {
            self.selected_row = null;
        }
    }

    pub fn setSelectedCell(self: *InteractiveTable, row: ?usize, col: ?usize) void {
        self.setSelectedRow(row);
        if (col) |c| {
            if (c < self.columns.items.len) {
                self.selected_col = c;
            }
        } else {
            self.selected_col = null;
        }
    }

    pub fn selectNextRow(self: *InteractiveTable) void {
        if (self.rows.items.len == 0) return;

        const current = self.selected_row orelse 0;
        var next = current + 1;

        // Find next selectable row
        while (next < self.rows.items.len and !self.rows.items[next].is_selectable) {
            next += 1;
        }

        if (next < self.rows.items.len) {
            self.selected_row = next;
            self.ensureRowVisible(next);
        }
    }

    pub fn selectPreviousRow(self: *InteractiveTable) void {
        if (self.rows.items.len == 0) return;

        const current = self.selected_row orelse self.rows.items.len;
        if (current == 0) return;

        var prev = current - 1;

        // Find previous selectable row
        while (prev > 0 and !self.rows.items[prev].is_selectable) {
            prev -= 1;
        }

        if (self.rows.items[prev].is_selectable) {
            self.selected_row = prev;
            self.ensureRowVisible(prev);
        }
    }

    pub fn selectNextColumn(self: *InteractiveTable) void {
        if (!self.allow_column_selection or self.columns.items.len == 0) return;

        const current = self.selected_col orelse 0;
        if (current + 1 < self.columns.items.len) {
            self.selected_col = current + 1;
        }
    }

    pub fn selectPreviousColumn(self: *InteractiveTable) void {
        if (!self.allow_column_selection or self.columns.items.len == 0) return;

        const current = self.selected_col orelse self.columns.items.len;
        if (current > 0) {
            self.selected_col = current - 1;
        }
    }

    pub fn sortByColumn(self: *InteractiveTable, column: usize, ascending: bool) void {
        if (column >= self.columns.items.len) return;

        self.sort_column = column;
        self.sort_ascending = ascending;

        // Simple bubble sort for demonstration - would use more efficient sort in production
        for (0..self.rows.items.len) |i| {
            for (i + 1..self.rows.items.len) |j| {
                const should_swap = if (ascending)
                    self.compareRows(i, j, column) > 0
                else
                    self.compareRows(i, j, column) < 0;

                if (should_swap) {
                    const temp = self.rows.items[i];
                    self.rows.items[i] = self.rows.items[j];
                    self.rows.items[j] = temp;
                }
            }
        }
    }

    pub fn draw(self: *InteractiveTable) void {
        self.drawBorder();
        if (self.show_headers) {
            self.drawHeaders();
        }
        self.drawRows();
    }

    fn drawBorder(self: InteractiveTable) void {
        // Top border with title
        moveCursor(self.bounds.y, self.bounds.x);
        print("{s}", .{Box.TOP_LEFT});

        if (self.title.len > 0) {
            const title_space = self.bounds.width - 4;
            const title_len = @min(self.title.len, title_space);
            const padding = (title_space - title_len) / 2;

            for (0..padding) |_| print("{s}", .{Box.HORIZONTAL});
            print(" {s}{s}{s} ", .{ Color.BOLD, self.title[0..title_len], Color.RESET });
            for (0..title_space - title_len - padding) |_| print("{s}", .{Box.HORIZONTAL});
        } else {
            for (0..self.bounds.width - 2) |_| print("{s}", .{Box.HORIZONTAL});
        }
        print("{s}", .{Box.TOP_RIGHT});

        // Side borders
        const content_height = self.getContentHeight();
        for (1..content_height + 1) |row| {
            moveCursor(self.bounds.y + @as(u32, @intCast(row)), self.bounds.x);
            print("{s}", .{Box.VERTICAL});
            moveCursor(self.bounds.y + @as(u32, @intCast(row)), self.bounds.x + self.bounds.width - 1);
            print("{s}", .{Box.VERTICAL});
        }

        // Bottom border
        moveCursor(self.bounds.y + content_height + 1, self.bounds.x);
        print("{s}", .{Box.BOTTOM_LEFT});
        for (0..self.bounds.width - 2) |_| print("{s}", .{Box.HORIZONTAL});
        print("{s}", .{Box.BOTTOM_RIGHT});
    }

    fn drawHeaders(self: InteractiveTable) void {
        if (self.columns.items.len == 0) return;

        const row_y = self.bounds.y + 1;
        var x = self.bounds.x + 1;

        // Row number column header if enabled
        if (self.show_row_numbers) {
            const num_width = self.getRowNumberWidth();
            moveCursor(row_y, x);
            print("{s}{s:^{}}{s}", .{ Color.BOLD, "#", num_width, Color.RESET });
            x += num_width;

            if (self.show_grid) {
                print("{s}", .{Box.VERTICAL});
                x += 1;
            }
        }

        // Column headers
        for (self.columns.items, 0..) |column, i| {
            moveCursor(row_y, x);

            const is_sort_column = if (self.sort_column) |sc| sc == i else false;
            const header_text = if (is_sort_column)
                std.fmt.allocPrint(self.columns.allocator, "{s} {s}", .{ column.name, if (self.sort_ascending) "▲" else "▼" }) catch column.name
            else
                column.name;

            const is_selected = if (self.allow_column_selection and self.selected_col) |sc| sc == i else false;
            if (is_selected) {
                print("{s}", .{Color.BG_BLUE});
            }

            switch (column.alignment) {
                .start => print("{s}{s:<{}}{s}", .{ Color.BOLD, header_text[0..@min(header_text.len, column.width)], column.width, Color.RESET }),
                .center => print("{s}{s:^{}}{s}", .{ Color.BOLD, header_text[0..@min(header_text.len, column.width)], column.width, Color.RESET }),
                .end => print("{s}{s:>{}}{s}", .{ Color.BOLD, header_text[0..@min(header_text.len, column.width)], column.width, Color.RESET }),
                .stretch => print("{s}{s:<{}}{s}", .{ Color.BOLD, header_text[0..@min(header_text.len, column.width)], column.width, Color.RESET }),
            }

            if (is_selected) {
                print("{s}", .{Color.RESET});
            }

            x += column.width;

            if (self.show_grid and i < self.columns.items.len - 1) {
                print("{s}", .{Box.VERTICAL});
                x += 1;
            }
        }

        // Header separator if grid is enabled
        if (self.show_grid) {
            moveCursor(self.bounds.y + 2, self.bounds.x);
            print("{s}", .{Box.VERTICAL});

            var sep_x = self.bounds.x + 1;
            if (self.show_row_numbers) {
                const num_width = self.getRowNumberWidth();
                for (0..num_width) |_| print("{s}", .{Box.HORIZONTAL});
                sep_x += num_width;
                print("{s}", .{Box.VERTICAL});
                sep_x += 1;
            }

            for (self.columns.items, 0..) |column, i| {
                for (0..column.width) |_| print("{s}", .{Box.HORIZONTAL});
                sep_x += column.width;

                if (i < self.columns.items.len - 1) {
                    print("{s}", .{Box.VERTICAL});
                    sep_x += 1;
                }
            }

            print("{s}", .{Box.VERTICAL});
        }
    }

    fn drawRows(self: InteractiveTable) void {
        const visible_rows = self.getVisibleRowCount();
        const start_row = if (self.show_headers and self.show_grid) 3 else if (self.show_headers) 2 else 1;

        for (0..visible_rows) |i| {
            const row_index = self.scroll_offset + i;
            if (row_index >= self.rows.items.len) break;

            const row = &self.rows.items[row_index];
            const row_y = self.bounds.y + start_row + @as(u32, @intCast(i));
            var x = self.bounds.x + 1;

            const is_selected = if (self.selected_row) |sr| sr == row_index else false;
            if (is_selected) {
                // Highlight entire row
                moveCursor(row_y, self.bounds.x + 1);
                for (0..self.bounds.width - 2) |_| print(" ");
                moveCursor(row_y, self.bounds.x + 1);
                print("{s}", .{Color.BG_BLUE});
            }

            // Row number
            if (self.show_row_numbers) {
                const num_width = self.getRowNumberWidth();
                moveCursor(row_y, x);
                print("{s}{:>{}}{s}", .{ Color.DIM, row_index + 1, num_width, Color.RESET });
                x += num_width;

                if (self.show_grid) {
                    print("{s}", .{Box.VERTICAL});
                    x += 1;
                }
            }

            // Row cells
            for (row.cells.items, 0..) |cell, col_i| {
                if (col_i >= self.columns.items.len) break;

                const column = self.columns.items[col_i];
                moveCursor(row_y, x);

                const cell_text = if (cell.len > column.width) cell[0..column.width] else cell;

                switch (column.alignment) {
                    .start => print("{s:<{}}", .{ cell_text, column.width }),
                    .center => print("{s:^{}}", .{ cell_text, column.width }),
                    .end => print("{s:>{}}", .{ cell_text, column.width }),
                    .stretch => print("{s:<{}}", .{ cell_text, column.width }),
                }

                x += column.width;

                if (self.show_grid and col_i < self.columns.items.len - 1) {
                    print("{s}", .{Box.VERTICAL});
                    x += 1;
                }
            }

            if (is_selected) {
                print("{s}", .{Color.RESET});
            }
        }
    }

    fn compareRows(self: InteractiveTable, row1: usize, row2: usize, column: usize) i8 {
        if (row1 >= self.rows.items.len or row2 >= self.rows.items.len or column >= self.columns.items.len) {
            return 0;
        }

        const r1 = &self.rows.items[row1];
        const r2 = &self.rows.items[row2];

        if (column >= r1.cells.items.len and column >= r2.cells.items.len) return 0;
        if (column >= r1.cells.items.len) return -1;
        if (column >= r2.cells.items.len) return 1;

        const cell1 = r1.cells.items[column];
        const cell2 = r2.cells.items[column];

        return std.mem.order(u8, cell1, cell2).compare(.eq);
    }

    fn ensureRowVisible(self: *InteractiveTable, row: usize) void {
        const visible_count = self.getVisibleRowCount();

        if (row < self.scroll_offset) {
            self.scroll_offset = row;
        } else if (row >= self.scroll_offset + visible_count) {
            self.scroll_offset = row - visible_count + 1;
        }
    }

    fn getContentHeight(self: InteractiveTable) usize {
        var height = self.bounds.height - 2; // Top and bottom borders
        if (self.show_headers) {
            height -= 1; // Header row
            if (self.show_grid) {
                height -= 1; // Header separator
            }
        }
        return height;
    }

    fn getVisibleRowCount(self: InteractiveTable) usize {
        return self.getContentHeight();
    }

    fn getRowNumberWidth(self: InteractiveTable) usize {
        if (self.rows.items.len == 0) return 1;
        const max_row = self.rows.items.len;
        if (max_row < 10) return 1;
        if (max_row < 100) return 2;
        if (max_row < 1000) return 3;
        return 4;
    }
};

/// Terminal control for raw input mode with mouse support
const TerminalMode = struct {
    original_termios: if (@import("builtin").os.tag == .linux or @import("builtin").os.tag == .macos) std.posix.termios else void,
    is_raw: bool,
    mouse_enabled: bool,
    caps: TermCaps,

    pub fn init() TerminalMode {
        return TerminalMode{
            .original_termios = if (@import("builtin").os.tag == .linux or @import("builtin").os.tag == .macos) undefined else {},
            .is_raw = false,
            .mouse_enabled = false,
            .caps = caps_mod.detectCaps(),
        };
    }

    pub fn enableRawMode(self: *TerminalMode) !void {
        if (@import("builtin").os.tag == .linux or @import("builtin").os.tag == .macos) {
            const stdin_fd = std.posix.STDIN_FILENO;

            // Get original terminal attributes
            self.original_termios = try std.posix.tcgetattr(stdin_fd);

            // Create raw mode termios
            var raw = self.original_termios;
            raw.iflag &= ~(std.posix.IGNBRK | std.posix.BRKINT | std.posix.PARMRK | std.posix.ISTRIP |
                std.posix.INLCR | std.posix.IGNCR | std.posix.ICRNL | std.posix.IXON);
            raw.oflag &= ~(std.posix.OPOST);
            raw.lflag &= ~(std.posix.ECHO | std.posix.ECHONL | std.posix.ICANON | std.posix.ISIG | std.posix.IEXTEN);
            raw.cflag &= ~(std.posix.CSIZE | std.posix.PARENB);
            raw.cflag |= std.posix.CS8;

            // Set minimum chars and timeout for read
            raw.cc[std.posix.VMIN] = 1;
            raw.cc[std.posix.VTIME] = 0;

            try std.posix.tcsetattr(stdin_fd, std.posix.TCSA.FLUSH, raw);
            self.is_raw = true;

            // Enable mouse support if terminal supports it
            try self.enableMouse();
        }
    }

    pub fn enableMouse(self: *TerminalMode) !void {
        const stdout = std.fs.File.stdout();
        const writer = stdout.writer();

        // Try SGR pixel mouse first for higher precision
        if (self.caps.supportsSgrPixelMouse) {
            mode.enableSgrPixelMouse(writer, self.caps) catch {
                // Fall back to regular SGR mouse
                if (self.caps.supportsSgrMouse) {
                    mode.enableSgrMouse(writer, self.caps) catch return;
                }
            };
        } else if (self.caps.supportsSgrMouse) {
            mode.enableSgrMouse(writer, self.caps) catch return;
        }

        self.mouse_enabled = true;
    }

    pub fn disableMouse(self: *TerminalMode) void {
        if (!self.mouse_enabled) return;

        const stdout = std.fs.File.stdout();
        const writer = stdout.writer();

        // Disable mouse modes in reverse order of enabling
        if (self.caps.supportsSgrPixelMouse) {
            mode.disableSgrPixelMouse(writer, self.caps) catch {};
        }
        if (self.caps.supportsSgrMouse) {
            mode.disableSgrMouse(writer, self.caps) catch {};
        }

        self.mouse_enabled = false;
    }

    pub fn disableRawMode(self: *TerminalMode) void {
        if (self.is_raw and (@import("builtin").os.tag == .linux or @import("builtin").os.tag == .macos)) {
            // Disable mouse support first
            self.disableMouse();

            const stdin_fd = std.posix.STDIN_FILENO;
            std.posix.tcsetattr(stdin_fd, std.posix.TCSA.FLUSH, self.original_termios) catch {};
            self.is_raw = false;
        }
    }
};

/// Enhanced input with history and tab completion
pub fn promptInputEnhanced(
    prompt: []const u8,
    allocator: std.mem.Allocator,
    history: *CommandHistory,
    completions: ?[]const []const u8,
) ![]u8 {
    var terminal_mode = TerminalMode.init();
    defer terminal_mode.disableRawMode();

    const stdin = std.fs.File.stdin();
    var input_buffer = std.array_list.Managed(u8).init(allocator);
    defer input_buffer.deinit();

    var cursor_pos: usize = 0;
    var temp_input: ?[]u8 = null;
    defer if (temp_input) |ti| allocator.free(ti);

    // Display initial prompt
    print("{s}{s}{s} ", .{ Color.BRIGHT_BLUE, prompt, Color.RESET });

    // Try to enable raw mode for better input handling
    terminal_mode.enableRawMode() catch {
        // Fall back to basic input if raw mode fails
        return promptInput(prompt, allocator);
    };

    while (true) {
        var buffer: [16]u8 = undefined;
        const bytes_read = stdin.read(&buffer) catch break;

        if (bytes_read == 0) break;

        if (bytes_read == 1) {
            const ch = buffer[0];

            switch (ch) {
                '\r', '\n' => {
                    // Enter - submit input
                    print("\n");
                    const result = try allocator.dupe(u8, input_buffer.items);
                    if (result.len > 0) {
                        try history.add(result);
                    }
                    history.resetNavigation();
                    return result;
                },
                '\t' => {
                    // Tab - completion
                    if (completions) |comps| {
                        const prefix = input_buffer.items;
                        const matches = findCompletions(prefix, comps, allocator) catch continue;
                        defer allocator.free(matches);

                        if (matches.len == 1) {
                            // Single match - complete it
                            input_buffer.clearAndFree();
                            try input_buffer.appendSlice(matches[0]);
                            cursor_pos = input_buffer.items.len;

                            // Redraw line
                            print("\r{s}{s}{s} {s}", .{ Color.BRIGHT_BLUE, prompt, Color.RESET, input_buffer.items });

                            // Clear to end of line if needed
                            print("\x1b[K");
                        } else if (matches.len > 1) {
                            // Multiple matches - show them
                            print("\n");
                            for (matches, 0..) |match, i| {
                                if (i > 0) print("  ");
                                print("{s}", .{match});
                            }
                            print("\n{s}{s}{s} {s}", .{ Color.BRIGHT_BLUE, prompt, Color.RESET, input_buffer.items });
                        }
                    }
                },
                127, 8 => {
                    // Backspace
                    if (cursor_pos > 0 and input_buffer.items.len > 0) {
                        _ = input_buffer.orderedRemove(cursor_pos - 1);
                        cursor_pos -= 1;

                        // Redraw line
                        print("\r{s}{s}{s} {s}", .{ Color.BRIGHT_BLUE, prompt, Color.RESET, input_buffer.items });
                        print("\x1b[K"); // Clear to end of line
                    }
                },
                3 => {
                    // Ctrl+C
                    print("\n");
                    return error.Interrupted;
                },
                4 => {
                    // Ctrl+D (EOF)
                    print("\n");
                    return allocator.dupe(u8, "");
                },
                27 => {
                    // Escape sequence - might be arrow key
                    continue;
                },
                else => {
                    // Regular character
                    if (ch >= 32 and ch <= 126) {
                        try input_buffer.insert(cursor_pos, ch);
                        cursor_pos += 1;

                        // Redraw line
                        print("\r{s}{s}{s} {s}", .{ Color.BRIGHT_BLUE, prompt, Color.RESET, input_buffer.items });
                    }
                },
            }
        } else if (bytes_read >= 3 and buffer[0] == 27 and buffer[1] == '[') {
            // ANSI escape sequences
            if (buffer[2] == '<') {
                // SGR mouse event
                if (terminal_mode.mouse_enabled) {
                    if (parseSgrMouseEvent(buffer[0..bytes_read])) |mouse_event| {
                        // Mouse event parsed successfully - for now just continue
                        // Individual widgets will handle mouse events when implemented
                        _ = mouse_event;
                        continue;
                    }
                }
            }

            switch (buffer[2]) {
                'A' => {
                    // Up arrow - previous command in history
                    if (history.navigateUp()) |cmd| {
                        // Save current input if it's the first navigation
                        if (history.current_index != null and history.current_index.? == history.entries.items.len - 1 and temp_input == null) {
                            temp_input = try allocator.dupe(u8, input_buffer.items);
                        }

                        input_buffer.clearAndFree();
                        try input_buffer.appendSlice(cmd);
                        cursor_pos = input_buffer.items.len;

                        // Redraw line
                        print("\r{s}{s}{s} {s}", .{ Color.BRIGHT_BLUE, prompt, Color.RESET, input_buffer.items });
                        print("\x1b[K"); // Clear to end of line
                    }
                },
                'B' => {
                    // Down arrow - next command in history
                    if (history.navigateDown()) |cmd| {
                        input_buffer.clearAndFree();
                        if (cmd.len > 0) {
                            try input_buffer.appendSlice(cmd);
                        } else if (temp_input) |ti| {
                            try input_buffer.appendSlice(ti);
                            allocator.free(ti);
                            temp_input = null;
                        }
                        cursor_pos = input_buffer.items.len;

                        // Redraw line
                        print("\r{s}{s}{s} {s}", .{ Color.BRIGHT_BLUE, prompt, Color.RESET, input_buffer.items });
                        print("\x1b[K"); // Clear to end of line
                    }
                },
                'C' => {
                    // Right arrow - move cursor right
                    if (cursor_pos < input_buffer.items.len) {
                        cursor_pos += 1;
                        print("\x1b[C"); // Move cursor right
                    }
                },
                'D' => {
                    // Left arrow - move cursor left
                    if (cursor_pos > 0) {
                        cursor_pos -= 1;
                        print("\x1b[D"); // Move cursor left
                    }
                },
                else => {},
            }
        }
    }

    return allocator.dupe(u8, input_buffer.items);
}

/// Simple input prompt (legacy version)
pub fn promptInput(prompt: []const u8, allocator: std.mem.Allocator) ![]u8 {
    print("{s}{s}{s} ", .{ Color.BRIGHT_BLUE, prompt, Color.RESET });

    const stdin = std.fs.File.stdin();
    var line_buffer: [2048]u8 = undefined;

    const bytes_read = try stdin.readAll(&line_buffer);
    if (bytes_read > 0) {
        const input = std.mem.trim(u8, line_buffer[0..bytes_read], "\r\n");
        const trimmed = std.mem.trim(u8, input, " \t\r\n");
        return allocator.dupe(u8, trimmed);
    }

    return allocator.dupe(u8, "");
}
